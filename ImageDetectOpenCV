import cv2
import numpy as np
from OpenGL.GL import *
from OpenGL.GLU import *
import glfw
import pywavefront  # 用于加载 OBJ 模型

# 加载自定义模型
try:
    model = pywavefront.Wavefront(
        'C:/Users/DR.RLW/Desktop/study/UAL/Year 3/Image_Recognition/Model/Lowpoly_tree_sample.obj', collect_faces=True
    )  # 替换为你的模型路径
except Exception as e:
    print(f"模型加载失败: {e}")
    exit()

# 旋转角度
rotation_angle_x = 0  # 绕 XY 轴的旋转角度
rotation_angle_yz = 0  # 绕 YZ 轴的旋转角度


def init_gl(width, height):
    """初始化 OpenGL 环境"""
    glClearColor(0.0, 0.0, 0.0, 1.0)
    glEnable(GL_DEPTH_TEST)
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, width / height, 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)


def draw_model(rotation_angle_x, rotation_angle_yz):
    """绘制导入的 3D 模型，并设置自定义颜色"""
    glPushMatrix()

    # 根据模式控制旋转
    glRotatef(rotation_angle_x, 0, 1, 0)  # 绕 Y 轴旋转（顺时针）
    glRotatef(rotation_angle_yz, 1, 0, 0)  # 绕 X 轴旋转（逆时针）
    glScalef(0.05, 0.05, 0.05)  # 调整模型缩放比例

    # 设置模型颜色为蓝色 (R=0, G=0, B=1)
    glColor3f(0.0, 0.0, 1.0)

    glBegin(GL_TRIANGLES)
    for mesh in model.mesh_list:  # 遍历模型中的每个网格
        for face in mesh.faces:  # 遍历网格中的每个面
            for vertex_i in face:  # 遍历面的每个顶点索引
                vertex = model.vertices[vertex_i]  # 获取顶点坐标
                glVertex3f(*vertex)  # 设置顶点
    glEnd()

    glPopMatrix()


def check_pattern(detected_pattern):
    """检查检测到的图案是否符合目标"""
    pattern1 = [1, 0, 0, 1, 0, 1, 1]
    pattern2 = [0, 1, 1, 0, 1, 1, 0]

    if detected_pattern == pattern1:
        print("Pattern 1 matched!")
        return 1  # pattern1: 顺时针旋转
    elif detected_pattern == pattern2:
        print("Pattern 2 matched!")
        return 2  # pattern2: 逆时针旋转
    return 0


def detect_pattern(frame, gray):
    """检测图案并返回中心点和颜色"""
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    circles = cv2.HoughCircles(
        blurred,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=30,
        param1=20,
        param2=25,
        minRadius=30,
        maxRadius=60
    )
    detected_centers = []
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            roi = gray[y - r:y + r, x - r:x + r]
            if roi.size > 0:
                avg_intensity = np.mean(roi)
                color = "black" if avg_intensity < 128 else "white"
                detected_centers.append((x, y, color))

                # 绘制检测到的圆形和中心点
                cv2.circle(frame, (x, y), r, (0, 255, 0), 4)
                cv2.circle(frame, (x, y), 2, (0, 0, 255), 3)

                # 在每个珠子旁边显示颜色信息
                cv2.putText(
                    frame,
                    color,  # 显示的颜色文本
                    (x + 10, y - 10),  # 显示位置，相对于圆心
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.7,
                    (255, 255, 255),  # 白色字体
                    2,  # 字体粗细
                    cv2.LINE_AA
                )
    return detected_centers


def get_detected_pattern(detected_centers):
    """生成检测到的图案矩阵"""
    pattern = []
    # 基于珠子的位置来判断其模式
    detected_centers.sort(key=lambda x: x[1])  # 按 y 坐标排序，确保从上到下处理
    for (x, y, color) in detected_centers:
        # 假设珠子在 y 坐标中排列的高度是根据某个模板
        if 50 <= y < 150:  # 第一行
            pattern.append(1 if color == "black" else 0)
        elif 150 <= y < 250:  # 第二行
            pattern.append(1 if color == "black" else 0)
        elif 250 <= y < 350:  # 第三行
            pattern.append(1 if color == "black" else 0)
        elif 350 <= y < 450:  # 第四行
            pattern.append(1 if color == "black" else 0)
        elif 450 <= y < 550:  # 第五行
            pattern.append(1 if color == "black" else 0)
    return pattern


# 初始化 GLFW 和摄像头
if not glfw.init():
    raise Exception("GLFW initialization failed")

width, height = 640, 480
window = glfw.create_window(width, height, "3D Rotating Model", None, None)
if not window:
    glfw.terminate()
    raise Exception("GLFW window creation failed")

glfw.make_context_current(window)
init_gl(width, height)

cap = cv2.VideoCapture(0)

global rotation_angle_x, rotation_angle_yz

while not glfw.window_should_close(window):
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    detected_centers = detect_pattern(frame, gray)
    detected_pattern = get_detected_pattern(detected_centers)

    # 转换 detected_pattern 为字符串
    pattern_str = "".join(str(cell) for cell in detected_pattern)

    # 在画面上添加文字
    cv2.putText(
        frame,                        # 图像
        f"Detected Pattern: {pattern_str}",  # 显示内容
        (10, 30),                     # 起始位置 (x, y)
        cv2.FONT_HERSHEY_SIMPLEX,     # 字体
        0.7,                          # 字体大小
        (255, 255, 255),              # 字体颜色 (白色)
        2,                            # 字体粗细
        cv2.LINE_AA                   # 抗锯齿
    )

    pattern_type = check_pattern(detected_pattern)
    
    if pattern_type == 1:  # 顺时针旋转
        rotation_angle_x += 1
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        gluLookAt(0, 0, 5, 0, 0, 0, 0, 1, 0)
        draw_model(rotation_angle_x, rotation_angle_yz)
        glfw.swap_buffers(window)

    elif pattern_type == 2:  # 逆时针旋转
        rotation_angle_yz -= 1
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        gluLookAt(0, 0, 5, 0, 0, 0, 0, 1, 0)
        draw_model(rotation_angle_x, rotation_angle_yz)
        glfw.swap_buffers(window)

    # 显示处理后的帧
    cv2.imshow('Flipped Frame', frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
glfw.terminate()

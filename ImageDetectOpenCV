import cv2
import numpy as np
from scipy.spatial.distance import cdist
from OpenGL.GL import *
from OpenGL.GLU import *
import glfw

# 容错设置
position_threshold = 30  # 最大位置偏差
match_ratio = 0.8        # 最少匹配比例

# 模板圆心的相对位置（行，列）
template_positions = [
    (0, 0),       # 第一行
    (-1, -1), (1, -1),  # 第二行
    (0, 0),       # 第三行
    (-1, 1), (1, 1),    # 第四行
    (0, 2)        # 第五行
]
template_positions = np.array(template_positions) * 50  # 转换到像素单位

# 旋转角度
rotation_angle = 0


def init_gl(width, height):
    """初始化 OpenGL 环境"""
    glClearColor(0.0, 0.0, 0.0, 1.0)
    glEnable(GL_DEPTH_TEST)
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, width / height, 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)


def draw_cube(rotation_angle):
    """绘制一个缓慢旋转的 3D 立方体"""
    glPushMatrix()
    glRotatef(rotation_angle, 0, 1, 0)  # 绕 Y 轴旋转

    glBegin(GL_QUADS)

    # 前面
    glColor3f(1, 0, 0)  # 红色
    glVertex3f(-0.5, -0.5, 0.5)
    glVertex3f(0.5, -0.5, 0.5)
    glVertex3f(0.5, 0.5, 0.5)
    glVertex3f(-0.5, 0.5, 0.5)

    # 后面
    glColor3f(0, 1, 0)  # 绿色
    glVertex3f(-0.5, -0.5, -0.5)
    glVertex3f(-0.5, 0.5, -0.5)
    glVertex3f(0.5, 0.5, -0.5)
    glVertex3f(0.5, -0.5, -0.5)

    # 左侧面
    glColor3f(0, 0, 1)  # 蓝色
    glVertex3f(-0.5, -0.5, -0.5)
    glVertex3f(-0.5, 0.5, -0.5)
    glVertex3f(-0.5, 0.5, 0.5)
    glVertex3f(-0.5, -0.5, 0.5)

    # 右侧面
    glColor3f(1, 1, 0)  # 黄色
    glVertex3f(0.5, -0.5, -0.5)
    glVertex3f(0.5, 0.5, -0.5)
    glVertex3f(0.5, 0.5, 0.5)
    glVertex3f(0.5, -0.5, 0.5)

    glEnd()
    glPopMatrix()


def detect_with_tolerance(detected_circles, template_positions):
    """检测到的点是否与模板匹配"""
    if len(detected_circles) == 0:
        return False

    # 计算每个检测到的点到模板点的距离
    distances = cdist(detected_circles, template_positions)

    # 判断每个模板点是否有对应的检测点
    matched = np.any(distances < position_threshold, axis=0)

    # 计算匹配比例
    match_percentage = np.sum(matched) / len(template_positions)
    return match_percentage >= match_ratio


def detect_pattern(frame, gray):
    """检测图案并返回中心点和颜色"""
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)

    circles = cv2.HoughCircles(
        blurred,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=20,
        param1=20,
        param2=30,
        minRadius=10,
        maxRadius=50
    )

    detected_centers = []
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            roi = gray[y - r:y + r, x - r:x + r]
            if roi.size > 0:
                avg_intensity = np.mean(roi)
                color = "black" if avg_intensity < 128 else "white"
                if color == "black":  # 只检测黑色珠子
                    detected_centers.append((x, y))
            cv2.circle(frame, (x, y), r, (0, 255, 0), 4)
            cv2.circle(frame, (x, y), 2, (0, 0, 255), 3)
    return np.array(detected_centers)


# 初始化 GLFW 和摄像头
if not glfw.init():
    raise Exception("GLFW initialization failed")

width, height = 640, 480
window = glfw.create_window(width, height, "3D Rotating Cube", None, None)
if not window:
    glfw.terminate()
    raise Exception("GLFW window creation failed")

glfw.make_context_current(window)
init_gl(width, height)

cap = cv2.VideoCapture(0)

global rotation_angle

while not glfw.window_should_close(window):
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    detected_centers = detect_pattern(frame, gray)

    if detect_with_tolerance(detected_centers, template_positions):
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        gluLookAt(0, 0, 5, 0, 0, 0, 0, 1, 0)
        draw_cube(rotation_angle)
        rotation_angle += 1  # 增加旋转角度，模拟缓慢旋转
        glfw.swap_buffers(window)

    flipped_frame = cv2.flip(frame, 1)
    cv2.imshow('Flipped Frame', flipped_frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
glfw.terminate()

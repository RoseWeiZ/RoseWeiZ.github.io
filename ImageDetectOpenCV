import cv2
import numpy as np
from OpenGL.GL import *
from OpenGL.GLU import *
import glfw

# 旋转角度
rotation_angle = 0


def init_gl(width, height):
    """初始化 OpenGL 环境"""
    glClearColor(0.0, 0.0, 0.0, 1.0)
    glEnable(GL_DEPTH_TEST)
    glViewport(0, 0, width, height)
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(45, width / height, 0.1, 100.0)
    glMatrixMode(GL_MODELVIEW)


def draw_cube(rotation_angle):
    """绘制一个缓慢旋转的 3D 立方体"""
    glPushMatrix()
    glRotatef(rotation_angle, 20, 20, 0)  # 绕 Z 轴旋转

    glBegin(GL_QUADS)

    # 前面
    glColor3f(1, 0, 0)  # 红色
    glVertex3f(-0.5, -0.5, 0.5)
    glVertex3f(0.5, -0.5, 0.5)
    glVertex3f(0.5, 0.5, 0.5)
    glVertex3f(-0.5, 0.5, 0.5)

    # 后面
    glColor3f(0, 1, 0)  # 绿色
    glVertex3f(-0.5, -0.5, -0.5)
    glVertex3f(-0.5, 0.5, -0.5)
    glVertex3f(0.5, 0.5, -0.5)
    glVertex3f(0.5, -0.5, -0.5)

    # 左侧面
    glColor3f(0, 0, 1)  # 蓝色
    glVertex3f(-0.5, -0.5, -0.5)
    glVertex3f(-0.5, 0.5, -0.5)
    glVertex3f(-0.5, 0.5, 0.5)
    glVertex3f(-0.5, -0.5, 0.5)

    # 右侧面
    glColor3f(1, 1, 0)  # 黄色
    glVertex3f(0.5, -0.5, -0.5)
    glVertex3f(0.5, 0.5, -0.5)
    glVertex3f(0.5, 0.5, 0.5)
    glVertex3f(0.5, -0.5, 0.5)

    glEnd()
    glPopMatrix()


def check_pattern(detected_pattern):
    """检查检测到的图案是否符合目标"""
    target_pattern = [[0], [1, 1], [0], [1, 1], [0]]
    #print("Detected Pattern:", detected_pattern)
    #print("Target Pattern:", target_pattern)
    if detected_pattern == target_pattern:
        print("Pattern matched!")
        return True
    return False


def detect_pattern(frame, gray):
    """检测图案并返回中心点和颜色"""
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)

    circles = cv2.HoughCircles(
        blurred,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=15,
        param1=20,
        param2=25,
        minRadius=10,
        maxRadius=50
    )

    detected_centers = []
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            roi = gray[y - r:y + r, x - r:x + r]
            if roi.size > 0:
                avg_intensity = np.mean(roi)
                color = "black" if avg_intensity < 128 else "white"
                detected_centers.append((x, y, color))
            cv2.circle(frame, (x, y), r, (0, 255, 0), 4)
            cv2.circle(frame, (x, y), 2, (0, 0, 255), 3)
    return detected_centers


def get_detected_pattern(detected_centers):
    """生成检测到的图案矩阵"""
    pattern = [[0], [0, 0], [0], [0, 0], [0]]
    for (x, y, color) in detected_centers:
        if y < 100:
            if color == "black":
                pattern[0][0] = 1
        elif 100 <= y < 200:
            if color == "black":
                pattern[1][0] = 1
                pattern[1][1] = 1
        elif 200 <= y < 300:
            if color == "black":
                pattern[2][0] = 1
        elif 300 <= y < 400:
            if color == "black":
                pattern[3][0] = 1
                pattern[3][1] = 1
        elif 400 <= y < 500:
            if color == "black":
                pattern[4][0] = 1
    return pattern


# 初始化 GLFW 和摄像头
if not glfw.init():
    raise Exception("GLFW initialization failed")

width, height = 640, 480
window = glfw.create_window(width, height, "3D Rotating Cube", None, None)
if not window:
    glfw.terminate()
    raise Exception("GLFW window creation failed")

glfw.make_context_current(window)
init_gl(width, height)

cap = cv2.VideoCapture(0)

global rotation_angle

while not glfw.window_should_close(window):
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    detected_centers = detect_pattern(frame, gray)
    detected_pattern = get_detected_pattern(detected_centers)

    if check_pattern(detected_pattern):
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        gluLookAt(0, 0, 5, 0, 0, 0, 0, 1, 0)
        draw_cube(rotation_angle)
        rotation_angle += 1  # 增加旋转角度，模拟缓慢旋转
        glfw.swap_buffers(window)

    flipped_frame = cv2.flip(frame, 1)
    cv2.imshow('Flipped Frame', flipped_frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
glfw.terminate()
